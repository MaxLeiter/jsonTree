{"Time": {"isLeapYear": {"path": "kernel/src/02/time.asm", "line": 128, "sections": {"Inputs": {"HL": "The year"}, "Outputs": {"A": "1 if it is a leap year; 0 if it is not"}}, "name": "isLeapYear", "description": "Determines whether the given year is a leap year."}, "convertTimeFromTicks": {"path": "kernel/src/02/time.asm", "line": 262, "sections": {"Inputs": {"DE": "Upper word of tick value", "HL": "Lower word of tick value"}, "Notes": "\n As of now, only the time is output correctly.", "Outputs": {"A": "Day of the week, from 0-6 with 0 being Sunday", "IX": "Current year", "C": "Current minute (0-59)", "B": "Current hour, from 0-23", "E": "Garbage", "D": "Current second (0-59)", "H": "Current day, from 0-30", "L": "Current month, from 0-11"}}, "name": "convertTimeFromTicks", "description": "Convert from ticks in seconds to time. The epoch is January 1st, 1997 (a Wednesday)."}, "setClock": {"path": "kernel/src/02/time.asm", "line": 15, "sections": {"Inputs": {"DE": "Upper word of a 32-bit tick value", "HL": "Lower word of a 32-bit tick value"}, "Outputs": {"A": "Preserved on success, error code on failure", "Z": "Set on success, reset on failure"}}, "name": "setClock", "description": "Sets the internal clock."}, "convertTimeToTicks": {"path": "kernel/src/02/time.asm", "line": 364, "sections": {"Inputs": {"IX": "Current year", "C": "Current minute (0-59)", "B": "Current hour (0-23)", "D": "Current second (0-59)", "H": "Current day (0-30)", "L": "Current month (0-11)"}, "Outputs": {"DE": "Upper word of tick value", "HL": "Lower word of tick value"}}, "name": "convertTimeToTicks", "description": "Converts a time structure to seconds since epoch."}, "getTime": {"path": "kernel/src/02/time.asm", "line": 473, "sections": {"Outputs": {"A": "Day of the week, from 0-6 with 0 being Sunday", "IX": "Current year", "C": "Current minute (0-59)", "B": "Current hour (0-23)", "D": "Current second (0-59)", "H": "Current day (0-30)", "L": "Current month (0-11)"}}, "name": "getTime", "description": "Gets the current time."}, "monthLength": {"path": "kernel/src/02/time.asm", "line": 74, "sections": {"Inputs": {"E": "The month (0-11)", "HL": "The year"}, "Outputs": {"A": "The amount of days in this month"}}, "name": "monthLength", "description": "Computes the amount of days in a given month."}, "getClock": {"path": "kernel/src/02/time.asm", "line": 47, "sections": {"Outputs": {"A": "Preserved on success, error code on failure", "Z": "Set on success, reset on failure", "DE": "Upper word of the 32-bit tick value", "HL": "Lower word of the 32-bit tick value"}}, "name": "getClock", "description": "Gets the internal clock."}, "clockSupported": {"path": "kernel/src/02/time.asm", "line": 1, "sections": {"Outputs": {"A": "Preserved on success; error code on failure", "Z": "Set when the clock is supported; reset otherwise"}}, "name": "clockSupported", "description": "Returns whether the clock is supported."}}, "Cryptography": {"sha1Init": {"path": "kernel/src/02/crypto.asm", "line": 1, "sections": {"Outputs": {"A": "Error code (on failure)", "IX": "location of allocated block (on success)", "Z": "Set on success, reset on failure"}}, "name": "sha1Init", "description": "Allocates a memory block to keep the state and result of a SHA1 hash operation.  The result is kept in the first 20 bytes of the allocated block.  You must use [[sha1Clean]] to deallocate the block; simply using [[free]] will result in a memory leak!"}, "sha1AddByte": {"path": "kernel/src/02/crypto.asm", "line": 128, "sections": {"Inputs": {"A": "Byte to add", "IX": "location of SHA1 state block"}}, "name": "sha1AddByte", "description": "Adds a single byte to the SHA1 hash input stream. Call this function once for each byte in the input stream, then call [[sha1Pad]]."}, "sha1Clean": {"path": "kernel/src/02/crypto.asm", "line": 74, "sections": {"Inputs": {"IX": "location of allocated block"}}, "name": "sha1Clean", "description": "Safely deallocates a SHA1 state block allocated by sha1Init."}, "sha1AddRange": {"path": "kernel/src/02/crypto.asm", "line": 419, "sections": {"Inputs": {"IX": "location of SHA1 state block", "HL": "location of range to add", "BC": "number of bytes to add"}}, "name": "sha1AddRange", "description": "Adds a range of bytes to a SHA1 hash.  This routine is equivalent to, but faster than, calling [[sha1AddByte]] many times."}, "sha1Pad": {"path": "kernel/src/02/crypto.asm", "line": 91, "sections": {"Inputs": {"IX": "location of SHA1 state block"}}, "name": "sha1Pad", "description": "Finishes the SHA1 computation by appending the required bits to the input.  Call this routine once after calling [[sha1AddByte]] for each input byte.  After this routine, the 8 bytes pointed to by IX will contain the big-endian SHA1 hash."}}, "Color": {"setLegacyLcdMode": {"path": "kernel/src/00/display-color.asm", "line": 405, "sections": {"Notes": "\n Legacy mode simulates a 96x64 monochrome screen with the help of [[fastCopy]]. Color \n graphics are not advised in legacy mode."}, "name": "setLegacyLcdMode", "description": "Sets the LCD to legacy mode."}, "readLcdRegister": {"path": "kernel/src/00/display-color.asm", "line": 113, "sections": {"Inputs": {"A": "Register"}, "Comments": "\n Destroys C", "Outputs": {"HL": "Value"}}, "name": "readLcdRegister", "description": "Reads a 16-bit value from a color LCD register"}, "clipColorRectangle": {"path": "kernel/src/00/display-color.asm", "line": 575, "sections": {"Inputs": {"IY": "color of the rectangle in R5G6B5 format", "C": "height of the rectangle in pixels", "B": "Y coordinate in pixels", "DE": "width of the rectangle in pixels", "HL": "X coordinate in pixels"}, "Notes": "\n The rectangle will be clipped to any LCD window already in \n place, and restore it afterwards."}, "name": "clipColorRectangle", "description": "Draws a clipped rectangle of the specified size with the specified color in color mode."}, "writeLcdRegister": {"path": "kernel/src/00/display-color.asm", "line": 49, "sections": {"Inputs": {"A": "Register", "HL": "Value"}, "Comments": "\n Destroys C"}, "name": "writeLcdRegister", "description": "Writes a 16-bit value to a color LCD register"}, "resetLegacyLcdMode": {"path": "kernel/src/00/display-color.asm", "line": 487, "sections": {}, "name": "resetLegacyLcdMode", "description": "Sets the LCD to color mode. Call this before you call [[getLcdLock]]."}, "colorSupported": {"path": "kernel/src/00/display-color.asm", "line": 40, "sections": {"Outputs": {"A": "errUnsupported if color is unsupported", "Z": "Set if supported, reset if unsupported"}}, "name": "colorSupported", "description": "Sets Z if color is supported on this device."}, "setLcdWindow": {"path": "kernel/src/00/display-color.asm", "line": 63, "sections": {"Inputs": {"B": "top border", "DE": "right border", "C": "bottom border ", "HL": "left border"}, "Notes": "\n Destroys C"}, "name": "setLcdWindow", "description": "Sets the LCD's clipping window. Values are inclusive."}, "colorLcdOff": {"path": "kernel/src/00/display-color.asm", "line": 207, "sections": {}, "name": "colorLcdOff", "description": "Turns off the color LCD and backlight."}, "fullScreenWindow": {"path": "kernel/src/00/display-color.asm", "line": 99, "sections": {}, "name": "fullScreenWindow", "description": "Sets the clipping window to fit the LCD screen in color mode."}, "clearColorLcd": {"path": "kernel/src/00/display-color.asm", "line": 326, "sections": {"Inputs": {"IY": "Color in 0bRRRRRGGGGGGBBBBB format"}, "Notes": "\n Overwrites the current clipping window."}, "name": "clearColorLcd", "description": "Sets all pixels on the LCD to a specified color in color mode."}, "checkLegacyLcdMode": {"path": "kernel/src/00/display-color.asm", "line": 539, "sections": {}, "name": "checkLegacyLcdMode", "description": "Sets Z if the current thread is in legacy mode."}, "colorLcdOn": {"path": "kernel/src/00/display-color.asm", "line": 141, "sections": {}, "name": "colorLcdOn", "description": "Initializes and turns on the color LCD in color mode."}}, "Text": {"drawStrXOR": {"path": "kernel/src/01/text.asm", "line": 287, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Left margin", "HL": "String"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string"}}, "name": "drawStrXOR", "description": "Draws a zero-delimited string to the screen buffer using XOR logic (inverts pixels)."}, "drawHexA": {"path": "kernel/src/01/text.asm", "line": 403, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "A": "Value"}, "Outputs": {"D, E": "Advanced to position of next character"}}, "name": "drawHexA", "description": "Draws the contents of A in hexadecimal to the screen buffer using OR logic (turns pixels ON)."}, "drawDecA": {"path": "kernel/src/01/text.asm", "line": 431, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "A": "Value"}, "Outputs": {"D, E": "Advanced to position of next character"}}, "name": "drawDecA", "description": "Draws the contents of A in decimal to the screen buffer using OR logic (turns pixels ON)."}, "drawDecACIX": {"path": "kernel/src/01/text.asm", "line": 567, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "ACIX": "Value"}, "Outputs": {"D, E": "Advanced to position of next character"}}, "name": "drawDecACIX", "description": "Draws the contents of ACIX in decimal to the screen buffer using OR logic (turns pixels ON)."}, "wrapStrAND": {"path": "kernel/src/01/text.asm", "line": 340, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Left margin", "B, C": "X Limit, Y Limit", "HL": "String pointer", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string", "HL": "Pointer to null terminator or next character that would have been drawn if the string hadn't run off-screen."}}, "name": "wrapStrAND", "description": "Draws a zero-delimited string to the screen buffer using AND logic (turns pixels OFF), and wraps it inside a rectangle, with character breaks."}, "drawCharXOR": {"path": "kernel/src/01/text.asm", "line": 78, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Character to print", "B": "Left margin", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Moved to next character position"}}, "name": "drawCharXOR", "description": "Draws a character to the screen buffer using XOR logic (inverts pixels)."}, "measureStr": {"path": "kernel/src/01/text.asm", "line": 664, "sections": {"Inputs": {"HL": "String to measure"}, "Notes": "\n The height of any string is always 5 pixels. This function does not support newlines.", "Outputs": {"A": "Width of string"}}, "name": "measureStr", "description": "Measures the width of a string in pixels."}, "drawStrAND": {"path": "kernel/src/01/text.asm", "line": 269, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Left margin", "HL": "String"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string"}}, "name": "drawStrAND", "description": "Draws a zero-delimited string to the screen buffer using AND logic (turns pixels OFF)."}, "drawChar": {"path": "kernel/src/01/text.asm", "line": 42, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Character to print", "B": "Left margin", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Moved to next character position"}}, "name": "drawChar", "description": "Draws a character to the screen buffer using OR logic (turns pixels ON)."}, "newline": {"path": "kernel/src/01/text.asm", "line": 3, "sections": {"Inputs": {"D, E": "X, Y", "B": "Left margin"}, "Notes": "\n This is identical to (but faster than) calling drawChar with '\\n'", "Outputs": {"D, E": "Moved down one line and to the left margin"}}, "name": "newline", "description": "Advances D, E to the next line of text"}, "drawHexHL": {"path": "kernel/src/01/text.asm", "line": 508, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "HL": "Value"}, "Outputs": {"D, E": "Advanced to position of next character"}}, "name": "drawHexHL", "description": "Draws the contents of HL in hexadecimal to the screen buffer using OR logic (turns pixels ON)."}, "measureChar": {"path": "kernel/src/01/text.asm", "line": 637, "sections": {"Inputs": {"A": "Character to measure"}, "Notes": "\n The height of each character is always 5 pixels. The width also often includes a column of empty pixels on the right (exceptions include '_').", "Outputs": {"A": "Width of character"}}, "name": "measureChar", "description": "Measures the width of a character in pixels."}, "drawStr": {"path": "kernel/src/01/text.asm", "line": 251, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Left margin", "HL": "String"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string"}}, "name": "drawStr", "description": "Draws a zero-delimited string to the screen buffer using OR logic (turns pixels ON)."}, "wrapStrXOR": {"path": "kernel/src/01/text.asm", "line": 362, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Left margin", "B, C": "X Limit, Y Limit", "HL": "String pointer", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string", "HL": "Pointer to null terminator or next character that would have been drawn if the string hadn't run off-screen."}}, "name": "wrapStrXOR", "description": "Draws a zero-delimited string to the screen buffer using XOR logic (inverts pixels), and wraps it inside a rectangle, with character breaks."}, "wrapStr": {"path": "kernel/src/01/text.asm", "line": 318, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Left margin", "B, C": "X Limit, Y Limit", "HL": "String pointer", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Advanced to position of the end of the string", "HL": "Pointer to null terminator or next character that would have been drawn if the string hadn't run off-screen."}}, "name": "wrapStr", "description": "Draws a zero-delimited string to the screen buffer using OR logic (turns pixels ON), and wraps it inside a rectangle, with character breaks."}, "drawDecHL": {"path": "kernel/src/01/text.asm", "line": 525, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "HL": "Value"}, "Outputs": {"D, E": "Advanced to position of next character"}}, "name": "drawDecHL", "description": "Draws the contents of HL in decimal to the screen buffer using OR logic (turns pixels ON)."}, "drawCharAND": {"path": "kernel/src/01/text.asm", "line": 60, "sections": {"Inputs": {"IY": "Screen buffer", "A": "Character to print", "B": "Left margin", "D, E": "X, Y"}, "Notes": "\n The left margin is only required if your string contains newlines or carriage returns.", "Outputs": {"D, E": "Moved to next character position"}}, "name": "drawCharAND", "description": "Draws a character to the screen buffer using AND logic (turns pixels OFF)."}}, "Flash": {"writeFlashByte": {"path": "kernel/src/00/flash.asm", "line": 43, "sections": {"Inputs": {"A": "Value", "HL": "Destination"}, "Notes": "\n Flash must be unlocked. This can only *reset* bits of Flash."}, "name": "writeFlashByte", "description": "Writes a single byte to Flash."}, "copyFlashExcept": {"path": "kernel/src/00/flash.asm", "line": 492, "sections": {"Inputs": {"A": "Destination page", "H": "High byte of address to stop copying at", "B": "Source page", "L": "High byte of address to resume copying at"}, "Notes": "\n Flash must be unlocked and the destination page must be cleared. \n \n If you want to copy all but 0x6000 to 0x6500, set HL to 0x6065."}, "name": "copyFlashExcept", "description": "Copies one Flash page to another, but omits a certain range of bytes in increments of 0x100 bytes."}, "lockFlash": {"path": "kernel/src/00/flash.asm", "line": 26, "sections": {}, "name": "lockFlash", "description": "Locks Flash and locks protected ports."}, "copySectorToSwap": {"path": "kernel/src/00/flash.asm", "line": 313, "sections": {"Inputs": {"A": "Any page within the sector to be copied"}, "Notes": "\n Flash must be unlocked."}, "name": "copySectorToSwap", "description": "Copies a single sector of Flash to the swap sector."}, "copyFlashPage": {"path": "kernel/src/00/flash.asm", "line": 694, "sections": {"Inputs": {"A": "Destination page", "B": "Source page"}, "Notes": "\n Flash must be unlocked and the desination page must be cleared."}, "name": "copyFlashPage", "description": "Copies one page of Flash to another."}, "unlockFlash": {"path": "kernel/src/00/flash.asm", "line": 4, "sections": {"Notes": "\n **Do not use this unless you know what you're doing.** \n \n Please call [[lockFlash]] when you finish what you're doing and don't spend too \n much time with Flash unlocked. Disable interrupts while Flash is unlocked."}, "name": "unlockFlash", "description": "Unlocks Flash and unlocks protected ports."}, "writeFlashBuffer": {"path": "kernel/src/00/flash.asm", "line": 118, "sections": {"Inputs": {"DE": "Address to write to", "HL": "Address to read from (in RAM)", "BC": "Length of data to write"}, "Notes": "\n Flash must be unlocked. Do not attempt to read your source data \n from Flash, you must load any data to be written into RAM. This \n will only *reset* bits of Flash."}, "name": "writeFlashBuffer", "description": "Writes several bytes of memory to Flash"}, "eraseSwapSector": {"path": "kernel/src/00/flash.asm", "line": 199, "sections": {"Notes": "\n Flash must be unlocked."}, "name": "eraseSwapSector", "description": "Erases the swap sector."}, "eraseFlashSector": {"path": "kernel/src/00/flash.asm", "line": 210, "sections": {"Inputs": {"A": "Any page within the target sector"}, "Notes": "\n Flash must be unlocked."}, "name": "eraseFlashSector", "description": "Erases one sector of Flash (generally 4 pages of Flash, or 64K) by setting each byte to 0xFF."}, "eraseFlashPage": {"path": "kernel/src/00/flash.asm", "line": 271, "sections": {"Inputs": {"A": "Target page"}, "Notes": "\n Flash must be unlocked. This is a very costly operation, and you \n may want to consider handling this logic yourself if you have to \n erase more than one page in a single sector"}, "name": "eraseFlashPage", "description": "Erases a single page of Flash."}}, "System": {"memoryAvailable": {"path": "kernel/src/00/memory.asm", "line": 219, "sections": {"Outputs": {"DE": "Largest allocatable sum", "BC": "Total memory available"}}, "name": "memoryAvailable", "description": "Finds the amount of memory available for use."}, "malloc": {"path": "kernel/src/00/memory.asm", "line": 274, "sections": {"Inputs": {"BC": "Length of requested section, in bytes"}, "Outputs": {"A": "Error code (on failure)", "IX": "First byte of allocated memory (on success)", "Z": "Set on success, reset on failure"}}, "name": "malloc", "description": "Allocates the specified amount of memory."}, "loadLibrary": {"path": "kernel/src/00/libraries.asm", "line": 6, "sections": {"Inputs": {"Z": "Set on success, reset on failure", "DE": "Pointer to full path of library"}}, "name": "loadLibrary", "description": "Loads a library into memory, or references one that may already be loaded."}, "memSeekToEnd": {"path": "kernel/src/00/memory.asm", "line": 144, "sections": {"Inputs": {"IX": "Pointer to anywhere in a section of allocated memory"}, "Outputs": {"IX": "Pointer to last byte of section"}}, "name": "memSeekToEnd", "description": "Move IX to the end of the memory section it points to."}, "memcheck": {"path": "kernel/src/00/memory.asm", "line": 163, "sections": {"Outputs": {"Z": "Set if OK, reset if broken"}, "Notes": "\n A reboot is probably required if this returns NZ."}, "name": "memcheck", "description": "Walks over memory and makes sure nothing has corrupted the allocation list."}, "memset": {"path": "kernel/src/00/memory.asm", "line": 88, "sections": {"Inputs": {"A": "Value to set", "IX": "Pointer to anywhere in allocated section"}}, "name": "memset", "description": "Sets the value of an entire allocated section of memory."}, "reboot": {"path": "kernel/src/00/boot.asm", "line": 41, "sections": {}, "name": "reboot", "description": "Restarts the device."}, "free": {"path": "kernel/src/00/memory.asm", "line": 412, "sections": {"Inputs": {"IX": "Pointer to first byte of section"}}, "name": "free", "description": "Frees a previously allocated section of memory"}, "reassignMemory": {"path": "kernel/src/00/memory.asm", "line": 39, "sections": {"Inputs": {"A": "Thread ID for new owner", "IX": "Pointer to any location within the target block."}}, "name": "reassignMemory", "description": "Reassigns a given block of memory to the specified thread ID."}, "shutdown": {"path": "kernel/src/00/boot.asm", "line": 5, "sections": {}, "name": "shutdown", "description": "Shuts off the device."}, "realloc": {"path": "kernel/src/00/memory.asm", "line": 510, "sections": {"Inputs": {"IX": "Block to resize", "BC": "New size"}, "Notes": "\n This function may have to move the memory that you've allocated. Consider the old pointer invalid and use \n the one returned from realloc instead.", "Outputs": {"A": "Preserved if success, error code if failure", "IX": "New memory", "Z": "Reset on failure, set on success"}}, "name": "realloc", "description": "Reallocates a block of memory at a different size and returns a new pointer."}, "calloc": {"path": "kernel/src/00/memory.asm", "line": 52, "sections": {"Inputs": {"A": "Size of element", "BC": "Number of elements"}, "Outputs": {"A": "Error code (on failure)", "IX": "First byte of allocated and zeroed memory (on success)", "Z": "Set on success, reset on failure"}}, "name": "calloc", "description": "Allocates memory for a given number of elements of a given size (that is, BC * A bytes total), then fills it with zeros."}, "contextSwitch": {"path": "kernel/src/00/interrupt.asm", "line": 1, "sections": {}, "name": "contextSwitch", "description": "Triggers a context switch early. This will transfer control from your thread to another and eventaully return to yours with interrupts enabled."}, "memSeekToStart": {"path": "kernel/src/00/memory.asm", "line": 111, "sections": {"Inputs": {"IX": "Pointer to anywhere in a section of allocated memory"}, "Outputs": {"IX": "Pointer to first byte of section"}}, "name": "memSeekToStart", "description": "Move IX to the beginning of the memory section it points to."}, "suspendDevice": {"path": "kernel/src/00/util.asm", "line": 1, "sections": {}, "name": "suspendDevice", "description": "Turns off the screen, enters low power mode, and halts system operation until the ON key is pressed."}}, "Strings": {"strchr": {"path": "kernel/src/00/strings.asm", "line": 93, "sections": {"Inputs": {"B": "Needle", "HL": "Haystack"}, "Outputs": {"A": "Destroyed", "Z": "Set if character found", "HL": "Pointer to first occurence of character"}}, "name": "strchr", "description": "Returns a pointer on the first occurence of a character in a string."}, "strtoi": {"path": "kernel/src/00/strings.asm", "line": 115, "sections": {"Inputs": {"B": "Maximum number of digits to convert", "HL": "Pointer on ASCII-encoded decimal"}, "Notes": "\n This will ignore leading zeros and has an unsigned range of 0 to 4,294,967,295. \n Signed numbers may be prefixed with '-' and have a range of -2,147,483,648 to \n 2,147,483,647. Strings whose numbers fall outside that range produce undefined \n behavior.", "Outputs": {"DEHL": "Converted word", "Z": "Set on success, reset on error"}}, "name": "strtoi", "description": "Converts an ASCII-encoded signed decimal into a number."}, "isAlphaNum": {"path": "kernel/src/00/util.asm", "line": 569, "sections": {"Inputs": {"A": "Character to test"}, "Outputs": {"C": "Set if the character is alphanumeric"}}, "name": "isAlphaNum", "description": "Tests if a character is a letter or a number."}, "toLower": {"path": "kernel/src/00/strings.asm", "line": 259, "sections": {"Inputs": {"HL": "Pointer to string"}, "Notes": "\n This modifies the string in-place."}, "name": "toLower", "description": "Converts every alpha character of a string to lowercase."}, "strcpy": {"path": "kernel/src/00/strings.asm", "line": 71, "sections": {"Inputs": {"DE": "Destination", "HL": "String pointer"}, "Notes": "\n This will trample into undefined territory if you try to copy a string into some \n allocated memory it won't fit in."}, "name": "strcpy", "description": "Copies a string."}, "toUpper": {"path": "kernel/src/00/strings.asm", "line": 283, "sections": {"Inputs": {"HL": "Pointer to string"}, "Notes": "\n This modifies the string in-place."}, "name": "toUpper", "description": "Converts every alpha character of a string to uppercase."}, "strlen": {"path": "kernel/src/00/strings.asm", "line": 1, "sections": {"Inputs": {"HL": "String pointer"}, "Outputs": {"BC": "String length"}}, "name": "strlen", "description": "Determines the length of a zero delimited string."}, "strcmp": {"path": "kernel/src/00/strings.asm", "line": 21, "sections": {"Inputs": {"DE": "String pointer", "HL": "String pointer"}, "Outputs": {"C": "Set if string HL is alphabetically earlier than string DE", "Z": "Set if equal, reset if not equal"}}, "name": "strcmp", "description": "Determines if two strings are equal, and checks alphabetical sort order."}, "strcmp_sort": {"path": "kernel/src/00/strings.asm", "line": 50, "sections": {"Inputs": {"DE": "Pointer to string pointer", "HL": "Pointer to string pointer"}, "Notes": "\n This routine is useful as the callback for the [[callbackSort]] routine. \n It allows sorting a list of pointers to strings in alphabetical order.", "Outputs": {"C": "Set if string (HL) is alphabetically earlier than string (DE)", "Z": "Set if equal, reset if not equal"}}, "name": "strcmp_sort", "description": "Compares strings at ((HL)) and ((DE)).  That is, calls [[indirect16HLDE]], then calls [[strcmp]]."}}, "Miscellaneous": {"rleCompress": {"path": "kernel/src/02/compression.asm", "line": 4, "sections": {"Inputs": {"DE": "Destination, cannot (yet) be the same location as original data", "HL": "Data to compress", "BC": "Size of uncompressed data"}, "Notes": "\n All bytes are considered literal, but 0x9B indicates a run. It is \n followed by the length of the run and the byte it consists of, \n respectively. \n \n For example, you may compress `01 02 02 02 02 02` as `01 9B 05 02`.", "Outputs": {"BC": "Size of compressed data", "AF": "Garbage"}}, "name": "rleCompress", "description": "Compresses data using a simple Run-Length-Encoding scheme."}, "rleCalculateCompressedLength": {"path": "kernel/src/02/compression.asm", "line": 92, "sections": {"Inputs": {"HL": "Data to compress", "BC": "Size of decompressed data"}, "Outputs": {"BC": "Size of compressed data", "AF": "Garbage"}}, "name": "rleCalculateCompressedLength", "description": "Calculates the size of some data after compression, but does not compress it."}, "indirect16HL": {"path": "kernel/src/00/util.asm", "line": 329, "sections": {}, "name": "indirect16HL", "description": "Performs HL = (HL)"}, "getKernelPatchNumber": {"path": "kernel/src/00/util.asm", "line": 449, "sections": {"Outputs": {"Z": "Set on success, reset on error", "HL": "Patch number"}, "Notes": "\n Kernel versions are MAJOR.MINOR.PATCH. For kernel 1.6.2, this returns 2."}, "name": "getKernelPatchNumber", "description": "Returns the kernel's patch number."}, "getKernelCommitsSinceTag": {"path": "kernel/src/00/util.asm", "line": 472, "sections": {"Outputs": {"Z": "Set on success, reset on error", "HL": "Number of commits"}, "Notes": "\n This will fail most of the time, as it is only included when running \n on a development kernel between releases."}, "name": "getKernelCommitsSinceTag", "description": "Returns how many commits have been made since the last kernel tag."}, "hexToHL": {"path": "kernel/src/00/util.asm", "line": 88, "sections": {"Inputs": {"HL": "String pointer"}, "Outputs": {"HL": "Value"}}, "name": "hexToHL", "description": "Converts a hexadecimal string to a number."}, "getRandom": {"path": "kernel/src/00/random.asm", "line": 18, "sections": {"Outputs": {"A": "Random number (0-255)"}, "Notes": "\n This is not cryptographically random."}, "name": "getRandom", "description": "Gets an 8-bit random number."}, "rleCalculateDecompressedLength": {"path": "kernel/src/02/compression.asm", "line": 214, "sections": {"Inputs": {"HL": "Data to decompress", "BC": "Size of compressed data"}, "Outputs": {"BC": "Size of decompressed data", "AF": "Garbage"}}, "name": "rleCalculateDecompressedLength", "description": "Calculates the decompressed size of some compressed data, but does not decompress it."}, "hexToA": {"path": "kernel/src/00/util.asm", "line": 128, "sections": {"Inputs": {"HL": "String pointer"}, "Outputs": {"A": "Value"}}, "name": "hexToA", "description": "Converts a hexadecimal string to a number."}, "isKernelDirty": {"path": "kernel/src/00/util.asm", "line": 551, "sections": {"Outputs": {"Z": "Set if dirty"}, "Notes": "\n A kernel is considered \"dirty\" if there were uncommitted changes when it was \n compiled."}, "name": "isKernelDirty", "description": "Checks for a dirty kernel."}, "callbackSort": {"path": "kernel/src/02/sort.asm", "line": 54, "sections": {"Inputs": {"IX": "Pointer to comparison function.", "DE": "Last element in array", "HL": "First element in array", "BC": "Size of element in bytes"}, "Notes": "\n The comparison function must affect the carry flag like cp (hl), (de) \n would.  (That is, set the carry flag if (HL) < (DE).)  All other registers \n must be preserved.  The algorithm (quicksort) uses an average of O(log n) \n stack space, with 8 bytes stack per recursion required.  Quicksort is \n in-place and is not a stable sort."}, "name": "callbackSort", "description": "Sorts an array of arbitrarily-sized blocks using a callback function to perform comparisons."}, "getKernelShortHash": {"path": "kernel/src/00/util.asm", "line": 500, "sections": {"Outputs": {"Z": "Set on success, reset on error", "HL": "Pointer on short hash string"}, "Notes": "\n This allocates memory to store the string. Deallocate it with [[free]] \n when you're done. \n \n This will fail most of the time, as it is only included when running \n on a development kernel between releases."}, "name": "getKernelShortHash", "description": "Retreives the kernel's short hash string."}, "indirect16HLDE": {"path": "kernel/src/00/util.asm", "line": 319, "sections": {"Notes": "\n This routine is useful as part of a callback for the callbackSort routine."}, "name": "indirect16HLDE", "description": "Performs HL = (HL) and DE = (DE)."}, "getKernelMinorVersion": {"path": "kernel/src/00/util.asm", "line": 429, "sections": {"Outputs": {"Z": "Set on success, reset on error", "HL": "Minor version number"}, "Notes": "\n Kernel versions are MAJOR.MINOR.PATCH. For kernel 1.6.2, this returns 6."}, "name": "getKernelMinorVersion", "description": "Returns the kernel's minor version number."}, "sleep": {"path": "kernel/src/00/util.asm", "line": 360, "sections": {"Inputs": {"HL": "delay in milliseconds"}, "Notes": "\n 117 or 121 T-states are added when called in 6 MHz mode to the delayed time, \n depending on the interrupt state upon calling."}, "name": "sleep", "description": "Delays a number of milliseconds."}, "integerSort": {"path": "kernel/src/02/sort.asm", "line": 1, "sections": {"Inputs": {"DE": "Last element in array", "HL": "first element in array"}, "Notes": "\n This routine is an in-place version of a radix sort, which has an O(k*n) \n runtime for k-bit numbers.  It also requires a smaller, fixed amount of \n stack space."}, "name": "integerSort", "description": "Sorts a specified array of 8-bit numbers using a fast (time complexity O(n)) algorithm."}, "getBootPage": {"path": "kernel/src/00/util.asm", "line": 242, "sections": {"Outputs": {"A": "Boot page"}}, "name": "getBootPage", "description": "Gets the boot page for this calculator."}, "getBootCodeVersionString": {"path": "kernel/src/00/util.asm", "line": 250, "sections": {"Outputs": {"HL": "String pointer"}, "Notes": "\n This allocates memory to hold the string. Deallocate it with [[free]] when you no longer need it."}, "name": "getBootCodeVersionString", "description": "Gets the version string from the device's boot code."}, "cpHLDE_sort": {"path": "kernel/src/00/util.asm", "line": 340, "sections": {"Inputs": {"DE": "Pointer to integer", "HL": "Pointer to integer"}, "Notes": "\n This routine is useful as the callback for the [[callbackSort]] routine. \n It allows sorting a list of 16-bit numbers.", "Output": "\n Flags: Same as z80 CP instruction."}, "name": "cpHLDE_sort", "description": "Compares 16-bit integers at (HL) and (DE).  That is, calls indirect16HLDE, then calls cpHLDE."}, "getKernelMajorVersion": {"path": "kernel/src/00/util.asm", "line": 414, "sections": {"Outputs": {"Z": "Set on success, reset on error", "HL": "Major version number"}, "Notes": "\n Kernel versions are MAJOR.MINOR.PATCH. For kernel 1.6.2, this returns 1."}, "name": "getKernelMajorVersion", "description": "Returns the kernel's major version number."}, "rleDecompress": {"path": "kernel/src/02/compression.asm", "line": 159, "sections": {"Inputs": {"DE": "Destination, cannot be the same location as original data", "HL": "Data to decompress", "BC": "Size of compressed data"}, "Outputs": {"BC": "Size of decompressed data", "AF": "Garbage"}}, "name": "rleDecompress", "description": "Decompresses data compressed with [[rleCompress]] or a compatible algorithm."}}, "Hardware": {"getIOLock": {"path": "kernel/src/00/locks.asm", "line": 13, "sections": {}, "name": "getIOLock", "description": "Locks the I/O port to the current thread."}, "getKeypadLock": {"path": "kernel/src/00/locks.asm", "line": 22, "sections": {}, "name": "getKeypadLock", "description": "Locks the keyboard to the current thread."}, "hasIOLock": {"path": "kernel/src/00/locks.asm", "line": 53, "sections": {}, "name": "hasIOLock", "description": "Sets Z if the current thread has a lock on the I/O port."}, "getBatteryLevel": {"path": "kernel/src/00/util.asm", "line": 175, "sections": {"Outputs": {"B": "Battery level"}, "Notes": "\n This returns a value from 0-255. The precision of this value varies by calculator \n model. 6 MHz platforms will return a 0 or a 255. 15 MHz platforms will return \n 0, 63, 127, 191, or 255 (multiples of 64), where 0 is critical."}, "name": "getBatteryLevel", "description": "Determines the approximate battery level."}, "hasLCDLock": {"path": "kernel/src/00/locks.asm", "line": 40, "sections": {}, "name": "hasLCDLock", "description": "Sets Z if the current thread has a lock on the LCD."}, "hasKeypadLock": {"path": "kernel/src/00/locks.asm", "line": 66, "sections": {}, "name": "hasKeypadLock", "description": "Sets Z if the current thread has a lock on the keyboard."}, "getUSBLock": {"path": "kernel/src/00/locks.asm", "line": 31, "sections": {}, "name": "getUSBLock", "description": "Locks the USB port to the current thread."}, "getLcdLock": {"path": "kernel/src/00/locks.asm", "line": 1, "sections": {}, "name": "getLcdLock", "description": "Locks the LCD to the current thread."}, "hasUSBLock": {"path": "kernel/src/00/locks.asm", "line": 79, "sections": {}, "name": "hasUSBLock", "description": "Sets Z if the current thread has a lock on the USB."}, "lcdDelay": {"path": "kernel/src/00/util.asm", "line": 165, "sections": {}, "name": "lcdDelay", "description": "Blocks until the LCD is ready to receive data."}}, "Threading": {"checkThread": {"path": "kernel/src/00/thread.asm", "line": 42, "sections": {"Inputs": {"A": "Thread ID"}, "Outputs": {"Z": "Set if running, reset if not found"}}, "name": "checkThread", "description": "Checks to see if the specified thread ID is still running."}, "setInitialHL": {"path": "kernel/src/00/thread.asm", "line": 698, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of HL"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialHL", "description": "Sets the initial value of the HL register for the specified thread."}, "launchProgram": {"path": "kernel/src/00/thread.asm", "line": 332, "sections": {"Inputs": {"DE": "Path to executable file"}, "Notes": "\n Call this with interrupts disabled if you wish to manipulate the thread \n before it starts (for example, to set the initial value of the registers). \n See [[startThread]] for details.", "Outputs": {"A": "Thread ID (on success), error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "launchProgram", "description": "Loads the specified file into memory as a program and starts a new thread for it. The file must be a valid KEXC executable."}, "setInitialIX": {"path": "kernel/src/00/thread.asm", "line": 750, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of IX"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialIX", "description": "Sets the initial value of the IX register for the specified thread."}, "getNextThreadID": {"path": "kernel/src/00/thread.asm", "line": 852, "sections": {"Inputs": {"B": "Thread index (0 for first thread)"}, "Notes": "\n It would be silly to call this without interrupts disabled. \n \n \n This will return your own thread at some point.", "Outputs": {"A": "Thread ID or 0xFF if no more threads", "B": "Incremented"}}, "name": "getNextThreadID", "description": "Gets the next running thread's ID."}, "getHeaderValue": {"path": "kernel/src/00/thread.asm", "line": 510, "sections": {"Inputs": {"A": "Thread ID", "B": "Header"}, "Notes": "\n This only works for threads that are valid KEXC formatted executables. \n This fails for threads manually created through other means.", "Outputs": {"A": "Preserved unless error", "Z": "Set if found, reset if not", "HL": "Header value"}}, "name": "getHeaderValue", "description": "Finds a header in the specified thread, and returns its value."}, "killCurrentThread": {"path": "kernel/src/00/thread.asm", "line": 144, "sections": {"Notes": "\n In most cases, it is preferrable to call [[exitThread]], which will use \n the exit function specified by the caller. \n \n \n This function cleans up all resources owned by that thread, including \n allocated memory, loaded libraries, file handles, etc."}, "name": "killCurrentThread", "description": "Kills the currently executing thread."}, "suspendCurrentThread": {"path": "kernel/src/00/thread.asm", "line": 817, "sections": {"Notes": "\n This function will not return until a second thread resumes the current thread."}, "name": "suspendCurrentThread", "description": "Suspends the currently executing thread."}, "setInitialDE": {"path": "kernel/src/00/thread.asm", "line": 672, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of DE"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialDE", "description": "Sets the initial value of the DE register for the specified thread."}, "setInitialA": {"path": "kernel/src/00/thread.asm", "line": 724, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "H": "Initial value of A"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialA", "description": "Sets the initial value of the A register for the specified thread."}, "getEntryPoint": {"path": "kernel/src/00/thread.asm", "line": 460, "sections": {"Inputs": {"A": "Thread ID"}, "Notes": "\n This gives you the location of the executable in memory. This does NOT \n get the KEXC entry point (KEXC_ENTRY_POINT) from the executable header. \n For that, use [[getHeaderValue]].", "Outputs": {"HL": "Entry point"}}, "name": "getEntryPoint", "description": "Retrieves the entry point for the specified thread."}, "killThread": {"path": "kernel/src/00/thread.asm", "line": 220, "sections": {"Inputs": {"A": "Thread ID"}, "Notes": "\n This function cleans up all resources owned by that thread, including \n allocated memory, loaded libraries, file handles, etc.", "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "killThread", "description": "Kills the specified thread."}, "setInitialIY": {"path": "kernel/src/00/thread.asm", "line": 776, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of IY"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialIY", "description": "Sets the initial value of the IY register for the specified thread."}, "setInitialBC": {"path": "kernel/src/00/thread.asm", "line": 646, "sections": {"Note": "\n Do **not** call this function on a thread that has already been started. \n You must have interrupts disabled when you call [[startThread]], and \n leave them disabled until after you have finished setting the initial \n state.", "Inputs": {"A": "Thread ID", "HL": "Initial value of BC"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setInitialBC", "description": "Sets the initial value of the BC register for the specified thread."}, "setReturnPoint": {"path": "kernel/src/00/thread.asm", "line": 622, "sections": {"Inputs": {"A": "Thread ID", "HL": "Return point"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "setReturnPoint", "description": "Sets the return point for the specified thread. This is set to [[killThread]] by default."}, "startThread": {"path": "kernel/src/00/thread.asm", "line": 54, "sections": {"Inputs": {"A": "Thread flags", "B": "Desired stack size / 2", "HL": "Pointer to thread executable"}, "Notes": "\n If you wish to manipulate this thread before it executes (to set the initial value \n of the registers, for instance), disable interrupts before calling startThread, and \n re-enable them when you're ready to start the thread. If you want to postpone \n starting the thread for an extended period of time, call [[suspendThread]] before \n re-enabling interrupts, and [[resumeThread]] when you're ready to start it.", "Outputs": {"A": "ID of new thread (on success); Error code (on failure)", "Z": "Set if successful, reset otherwise"}}, "name": "startThread", "description": "Starts a new thread."}, "readSignal": {"path": "kernel/src/00/signals.asm", "line": 65, "sections": {"Outputs": {"B": "Message type", "Z": "Set if a signal was read, reset if there are no pending signals", "HL": "Message payload"}}, "name": "readSignal", "description": "Reads the next pending signal from this thread's signal queue."}, "exitThread": {"path": "kernel/src/00/thread.asm", "line": 437, "sections": {"Notes": "\n This is preferred to [[killCurrentThread]], since it will go through the caller-set \n exit function. This is often [[killCurrentThread]] anyway, but it may be set to a \n custom value by the code that intitialized the thread."}, "name": "exitThread", "description": "Immediately terminates the running thread."}, "createSignal": {"path": "kernel/src/00/signals.asm", "line": 8, "sections": {"Inputs": {"A": "Target thread ID", "B": "Message type", "HL": "Message payload"}, "Notes": "\n The receiving thread may use [[readSignal]] to consume this \n message."}, "name": "createSignal", "description": "Signals another thread with a simple message."}, "getCurrentThreadID": {"path": "kernel/src/00/thread.asm", "line": 26, "sections": {"Outputs": {"A": "Thread ID"}}, "name": "getCurrentThreadID", "description": "Gets the ID of the currently executing thread."}, "resumeThread": {"path": "kernel/src/00/thread.asm", "line": 835, "sections": {"Inputs": {"A": "Thread ID"}}, "name": "resumeThread", "description": "Resumes the specified thread."}}, "Concurrency": {"mutexUnlock": {"path": "kernel/src/00/concurrency.asm", "line": 33, "sections": {"Inputs": {"HL": "Pointer to mutex byte"}, "Notes": "\n If the mutex is not locked already by this thread, an error will be returned.", "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "mutexUnlock", "description": "Atomically unlocks a mutex."}, "condWait": {"path": "kernel/src/00/concurrency.asm", "line": 90, "sections": {"Inputs": {"IX": "Pointer to condition variable", "HL": "Pointer to locked mutex"}, "Notes": "\n This function will enable interrupts. \n \n You must provide a pre-initialized mutex and condition variable to this \n function. This function will release the mutex and suspend the thread, \n then awaken it when the condition variable is notified. The mutex will \n then be reacquired."}, "name": "condWait", "description": "Blocks until another thread notifies the condition variable. "}, "mutexInit": {"path": "kernel/src/00/concurrency.asm", "line": 54, "sections": {"Inputs": {"HL": "Pointer to mutex byte"}}, "name": "mutexInit", "description": "Initializes a mutex byte at (HL)."}, "condInit": {"path": "kernel/src/00/concurrency.asm", "line": 63, "sections": {"Outputs": {"A": "Error code (on failure)", "IX": "Pointer to condition variable (on success)", "Z": "Set on success, reset on failure"}, "Notes": "\n This allocates memory for the condition variable. You should deallocate it \n with [[free]] when you're done."}, "name": "condInit", "description": "Returns a pointer to a new condition variable."}, "condNotifyAll": {"path": "kernel/src/00/concurrency.asm", "line": 120, "sections": {"Inputs": {"IX": "Pointer to condition variable"}, "Notes": "\n Threads awoken by this mechanism should check to see if the condition variable \n they were waiting for is still true. \n \n The thread calling this function must lock the associated mutex before invoking \n this function, and release it afterwards."}, "name": "condNotifyAll", "description": "Awakens all threads waiting on a condition variable."}, "condNotifyOne": {"path": "kernel/src/00/concurrency.asm", "line": 145, "sections": {"Inputs": {"IX": "Pointer to condition variable"}, "Notes": "\n Threads awoken by this mechanism should check to see if the condition variable \n they were waiting for is still true. \n \n The thread calling this function must lock the associated mutex before invoking \n this function, and release it afterwards."}, "name": "condNotifyOne", "description": "Awakens the thread that has been waiting the longest on a condition variable."}, "mutexLock": {"path": "kernel/src/00/concurrency.asm", "line": 1, "sections": {"Inputs": {"HL": "Pointer to mutex byte"}, "Notes": "\n The application should have already initialized the mutex with [[initMutex]]. \n \n This function blocks until the mutex is locked. \n \n Interrupts will be enabled to do a context switch (if needed) and will be \n restored to their original state afterwards."}, "name": "mutexLock", "description": "Atomically locks a mutex."}}, "Filesystem": {"fileExists": {"path": "kernel/src/00/filesystem.asm", "line": 64, "sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"Z": "Set if file exists, reset if not"}}, "name": "fileExists", "description": "Determines if a file exists."}, "checkFilesystem": {"path": "kernel/src/00/filesystem.asm", "line": 898, "sections": {"Outputs": {"A=0": "No problems", "A/4": "Unclosed new file entries found", "A/3": "Invalid heap blocks found", "A/2": "Invalid FAT entries found", "A/1": "Unformatted pages found"}, "Notes": "\n Passing A into [[fixFilesystem]] is the appropriate course of action if A is nonzero."}, "name": "checkFilesystem", "description": "Checks the integrity of the filesystem and sets certain bits of A with the results."}, "directoryExists": {"path": "kernel/src/00/filesystem.asm", "line": 86, "sections": {"Inputs": {"DE": "Path to directory (string pointer)"}, "Outputs": {"Z": "Set if file exists, reset if not"}}, "name": "directoryExists", "description": "Determines if a directory exists."}, "listDirectory": {"path": "kernel/src/00/filesystem.asm", "line": 95, "sections": {"Inputs": {"DE": "Path to directory", "HL": "Callback"}, "Notes": "\n This function will call your callback every time it encounters a \n relevant entry on the filesystem. You are free to use IX, IY, and \n the shadow registers in this callback, but must preserve all other \n registers. Your function will be called with the following state: \n \n * HL: Address of entry \n * BC: Length of entry \n * A: Type of entry \n * kernelGarbage: Name of entry \n * Correct page swapped into bank A \n * Interrupts disabled (do not enable them) \n \n You must leave these registers intact.", "Outputs": {"A": "Error code on failure, preserved on success", "Z": "Set on success, reset on failure"}}, "name": "listDirectory", "description": "Lists the contents of a directory on the filesystem."}, "renameFile": {"path": "kernel/src/00/filesystem.asm", "line": 951, "sections": {"Inputs": {"DE": "Path to file (string pointer)", "HL": "New filename"}, "Outputs": {"A": "Preserved on success, error code on failure", "Z": "Set if the file was renamed, reset if file did not exist"}}, "name": "renameFile", "description": "Renames a file."}, "fixKFS": {"path": "kernel/src/00/filesystem.asm", "line": 892, "sections": {}, "name": "fixKFS", "description": "Fixes issues found from [[checkFilesystem]]"}, "createDirectory": {"path": "kernel/src/00/filesystem.asm", "line": 617, "sections": {"Inputs": {"DE": "Path to new directory"}, "Outputs": {"A": "Flash page (on success); Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Address relative to 0x4000 (on success)"}}, "name": "createDirectory", "description": "Creates a new directory in the filesystem and returns information about the new filesystem entry."}, "deleteFile": {"path": "kernel/src/00/filesystem.asm", "line": 9, "sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"A": "Preserved on success, error code on failure", "Z": "Set if file was deleted, reset if file did not exist"}}, "name": "deleteFile", "description": "Deletes a file or symbolic link."}}, "Maths": {"sdivACbyDE": {"path": "kernel/src/00/math.asm", "line": 469, "sections": {"Output": "\n AC: AC / DE \n HL: Remainder", "Notes": "\n B is destroyed"}, "name": "sdivACbyDE", "description": "Performs `AC = AC / DE`. The operation is signed."}, "smax": {"path": "kernel/src/00/math.asm", "line": 531, "sections": {"Inputs": {"DE": "integer", "HL": "integer"}, "Outputs": {"DE": "the smallest of the previous HL and DE", "HL": "the largest of the previous HL and DE"}}, "name": "smax", "description": "Returns the largest between HL and DE. The operation is signed."}, "mul8By8": {"path": "kernel/src/00/math.asm", "line": 56, "sections": {"Inputs": {"H": "Multiplier", "E": "Multiplicand"}, "Outputs": {"HL": "Product of H and E."}}, "name": "mul8By8", "description": "Performs an unsigned multiplication of H and E"}, "add16To32": {"path": "kernel/src/00/math.asm", "line": 310, "sections": {}, "name": "add16To32", "description": "Performs `ACIX = ACIX + DE`"}, "mul16By16": {"path": "kernel/src/00/math.asm", "line": 123, "sections": {"Inputs": {"DE": "Multiplier", "BC": "Multiplicand"}, "Outputs": {"DEHL": "Product of DE and BC."}}, "name": "mul16By16", "description": "Performs an unsigned multiplication of DE and BC."}, "mul16By8": {"path": "kernel/src/00/math.asm", "line": 88, "sections": {"Inputs": {"A": "Multiplier", "DE": "Multiplicand"}, "Outputs": {"AHL": "Product of A and DE."}}, "name": "mul16By8", "description": "Performs an unsigned multiplication of A and DE."}, "cpBCDE": {"path": "kernel/src/00/math.asm", "line": 19, "sections": {"Output": "\n Same as z80 CP instruction."}, "name": "cpBCDE", "description": "Compares DE to BC."}, "div32By16": {"path": "kernel/src/00/math.asm", "line": 201, "sections": {"Outputs": {"B": "0", "HL": "Remainder", "ACIX": "ACIX / DE"}}, "name": "div32By16", "description": "Performs `ACIX = ACIX / DE`"}, "divACByDE": {"path": "kernel/src/00/math.asm", "line": 348, "sections": {"Outputs": {"AC": "AC / DE", "HL": "Remainder"}}, "name": "divACByDE", "description": "Performs `AC = AC / DE`"}, "divHLByC": {"path": "kernel/src/00/math.asm", "line": 329, "sections": {"Outputs": {"A": "Remainder", "HL": "HL / C"}}, "name": "divHLByC", "description": "Performs `HL = HL / C`"}, "sub16From32": {"path": "kernel/src/00/math.asm", "line": 287, "sections": {}, "name": "sub16From32", "description": "Performs `ACIX = ACIX - DE`"}, "smin": {"path": "kernel/src/00/math.asm", "line": 511, "sections": {"Inputs": {"DE": "integer", "HL": "integer"}, "Outputs": {"DE": "the largest of the previous HL and DE", "HL": "the smallest of the previous HL and DE"}}, "name": "smin", "description": "Returns the smallest between HL and DE. The operation is signed."}, "crc16_updateBuffer": {"path": "kernel/src/00/crc.asm", "line": 40, "sections": {"Inputs": {"DE": "Current CRC16", "HL": "Pointer to buffer", "BC": "Number of bytes to process"}, "Outputs": {"DE": "Updated CRC16"}}, "name": "crc16_updateBuffer", "description": "Updates the current CRC16 with the CRC16 of a buffer of given size."}, "icos": {"path": "kernel/src/00/math.asm", "line": 567, "sections": {"Inputs": {"A": "Angle"}, "Notes": "\n The input angle has a period of 256, and the output value will be \n in the range [-64, 64] to represent [-1, 1]. \n \n That is, to get the cosine of 180 degrees, pass in 128 and you will \n receive -64 (two's compliment).", "Outputs": {"A": "Sine of the angle, scaled to 64"}}, "name": "icos", "description": "Returns the cosine of the given angle."}, "mul32By8": {"path": "kernel/src/00/math.asm", "line": 166, "sections": {"Outputs": {"DEHL": "product of DEHL and A"}}, "name": "mul32By8", "description": "Performs an unsigned multiplication of DEHL and A."}, "cpHLBC": {"path": "kernel/src/00/math.asm", "line": 10, "sections": {"Output": "\n Same as z80 CP instruction."}, "name": "cpHLBC", "description": "Compares HL to BC."}, "crc16_init": {"path": "kernel/src/00/crc.asm", "line": 1, "sections": {"Outputs": {"DE": "Fresh CRC value"}}, "name": "crc16_init", "description": "Initializes a Cyclic Redundancy Check."}, "crc16_updateByte": {"path": "kernel/src/00/crc.asm", "line": 9, "sections": {"Inputs": {"A": "byte to process", "DE": "Current CRC16"}, "Outputs": {"DE": "Updated CRC16"}}, "name": "crc16_updateByte", "description": "Updates the current CRC16 with the CRC16 of a single byte."}, "smul16By8": {"path": "kernel/src/00/math.asm", "line": 32, "sections": {"Inputs": {"A": "Multiplier", "DE": "Multiplicand"}, "Outputs": {"HL": "Product of A and DE."}}, "name": "smul16By8", "description": "Performs a signed multiplication of A and DE."}, "cpHLDE": {"path": "kernel/src/00/math.asm", "line": 1, "sections": {"Output": "\n Same as z80 CP instruction."}, "name": "cpHLDE", "description": "Compares HL to DE."}, "div8By8": {"path": "kernel/src/00/math.asm", "line": 229, "sections": {"Outputs": {"A": "Remainder", "D": "D / E"}}, "name": "div8By8", "description": "Performs `D = D / E`"}, "isin": {"path": "kernel/src/00/math.asm", "line": 551, "sections": {"Inputs": {"A": "Angle"}, "Notes": "\n The input angle has a period of 256, and the output value will be \n in the range [-64, 64] to represent [-1, 1]. \n \n That is, to get the cosine of 180 degrees, pass in 128 and you will \n receive 0.", "Outputs": {"A": "Sine of the angle, scaled to 64"}}, "name": "isin", "description": "Returns the sine of the given angle."}}, "Input": {"flushKeys": {"path": "kernel/src/00/keyboard.asm", "line": 19, "sections": {}, "name": "flushKeys", "description": "Blocks until all keys are released."}, "getKey": {"path": "kernel/src/00/keyboard.asm", "line": 43, "sections": {"Outputs": {"A": "Key code"}}, "name": "getKey", "description": "Returns the currently pressed key code, or zero if no keys are pressed."}, "waitKey": {"path": "kernel/src/00/keyboard.asm", "line": 1, "sections": {"Outputs": {"A": "Key code"}}, "name": "waitKey", "description": "Blocks until a key is pressed, then returns that key code."}}, "Display": {"drawVLineAND": {"path": "kernel/src/02/graphics.asm", "line": 137, "sections": {"Inputs": {"IY": "screen buffer", "C": "height", "A, L": "X, Y"}}, "name": "drawVLineAND", "description": "Draws a vertical line on the screen buffer using AND (turns pixels OFF) logic. Does clipping."}, "putSpriteXOR": {"path": "kernel/src/00/display.asm", "line": 125, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}}, "name": "putSpriteXOR", "description": "Draws an 8xB sprite on the screen buffer using XOR (invert) logic."}, "drawLine": {"path": "kernel/src/00/display.asm", "line": 908, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X1, Y1", "H, L": "X2, Y2"}, "Notes": "\n This function does not clip lines to the screen boundaries."}, "name": "drawLine", "description": "Draws a line on the screen buffer using OR (turns pixels ON) logic."}, "allocScreenBuffer": {"path": "kernel/src/00/memory.asm", "line": 14, "sections": {"Outputs": {"IY": "Screen buffer"}}, "name": "allocScreenBuffer", "description": "Allocates a 768-byte screen buffer."}, "rectAND": {"path": "kernel/src/02/graphics.asm", "line": 280, "sections": {"Inputs": {"IY": "Screen buffer", "C, B": "Width, height", "E, L": "X, Y"}}, "name": "rectAND", "description": "Draws a filled rectangle on the screen buffer using AND (turns pixels OFF) logic."}, "putSpriteAND": {"path": "kernel/src/00/display.asm", "line": 286, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}}, "name": "putSpriteAND", "description": "Draws an 8xB sprite on the screen buffer using AND (turns pixels OFF) logic."}, "putSpriteOR": {"path": "kernel/src/00/display.asm", "line": 457, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}}, "name": "putSpriteOR", "description": "Draws an 8xB sprite on the screen buffer using OR (turns pixels ON) logic."}, "putSprite16XOR": {"path": "kernel/src/00/display.asm", "line": 625, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}, "Notes": "\n Each 16-wide group of pixels is represented by two adjacent octets."}, "name": "putSprite16XOR", "description": "Draws a 16xB sprite on the screen buffer using XOR (invert) logic."}, "putSprite16OR": {"path": "kernel/src/00/display.asm", "line": 718, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}, "Notes": "\n Each 16-wide group of pixels is represented by two adjacent octets."}, "name": "putSprite16OR", "description": "Draws a 16xB sprite on the screen buffer using OR (turns pixels ON) logic."}, "setPixel": {"path": "kernel/src/02/graphics.asm", "line": 57, "sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}}, "name": "setPixel", "description": "Sets (turns on) a pixel on the screen buffer."}, "rectXOR": {"path": "kernel/src/02/graphics.asm", "line": 172, "sections": {"Inputs": {"IY": "Screen buffer", "C, B": "Width, height", "E, L": "X, Y"}}, "name": "rectXOR", "description": "Draws a filled rectangle on the screen buffer using XOR (invert) logic."}, "drawVLine": {"path": "kernel/src/02/graphics.asm", "line": 103, "sections": {"Inputs": {"IY": "screen buffer", "C": "height", "A, L": "X, Y"}}, "name": "drawVLine", "description": "Draws a vertical line on the screen buffer using OR (turns pixels ON) logic. Does clipping."}, "freeScreenBuffer": {"path": "kernel/src/00/memory.asm", "line": 28, "sections": {"Inputs": {"IY": "Screen buffer"}}, "name": "freeScreenBuffer", "description": "Deallocates a screen buffer allocated with [[allocScreenBuffer]]"}, "putSprite16AND": {"path": "kernel/src/00/display.asm", "line": 811, "sections": {"Inputs": {"IY": "Screen buffer", "D, E": "X, Y", "B": "Height", "HL": "Sprite pointer"}, "Notes": "\n Each 16-wide group of pixels is represented by two adjacent octets."}, "name": "putSprite16AND", "description": "Draws a 16xB sprite on the screen buffer using AND (turns pixels OFF) logic."}, "invertPixel": {"path": "kernel/src/02/graphics.asm", "line": 88, "sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}}, "name": "invertPixel", "description": "Inverts a pixel on the screen buffer."}, "fastCopy": {"path": "kernel/src/00/display.asm", "line": 62, "sections": {"Inputs": {"IY": "Screen buffer"}, "Notes": "\n This routine will return immediately without drawing to the LCD if the calling thead does not have an \n LCD lock. Acquire one with [[getLcdLock]]. \n \n On a TI-84+ CSE, this routine will draw the 96x64 monochrome buffer (the \"legacy\" buffer) to the LCD. \n The LCD should be set to legacy mode (see [[setLegacyLcdMode]])."}, "name": "fastCopy", "description": "Copies the screen buffer to the LCD."}, "clearBuffer": {"path": "kernel/src/00/display.asm", "line": 41, "sections": {"Inputs": {"IY": "Screen buffer"}}, "name": "clearBuffer", "description": "Turns off all pixels on a screen buffer."}, "rectOR": {"path": "kernel/src/00/display.asm", "line": 1178, "sections": {"Inputs": {"IY": "Screen buffer", "C, B": "Width, height", "E, L": "X, Y"}}, "name": "rectOR", "description": "Draws a filled rectangle on the screen buffer using OR (turns pixels ON) logic."}, "getPixel": {"path": "kernel/src/02/graphics.asm", "line": 1, "sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}, "Notes": "\n If the pixel is on, HL & A is nonzero.", "Outputs": {"A": "Mask", "HL": "Address of pixel"}}, "name": "getPixel", "description": "Finds the address of and mask for a pixel on the screen buffer."}, "resetPixel": {"path": "kernel/src/02/graphics.asm", "line": 72, "sections": {"Inputs": {"IY": "Screen buffer", "A,L": "X, Y"}}, "name": "resetPixel", "description": "Sets (turns on) a pixel on the screen buffer."}}, "Filestreams": {"getStreamBuffer": {"path": "kernel/src/00/filestreams.asm", "line": 483, "sections": {"Inputs": {"D": "Stream ID"}, "Notes": "\n For read-only streams, modifying this buffer could have unforseen consequences and it will not be copied back to the file. \n For writable streams, make sure you call [[flush]] if you modify this buffer and want to make the changes persist to the file.", "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Stream buffer (on success)"}}, "name": "getStreamBuffer", "description": "Gets the address of a stream's memory buffer."}, "streamWriteBuffer": {"path": "kernel/src/00/filestreams.asm", "line": 1295, "sections": {"Inputs": {"IX": "Buffer address", "D": "Stream ID", "BC": "Length"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamWriteBuffer", "description": "Writes a buffer of bytes to a file stream and advances the stream."}, "streamWriteWord": {"path": "kernel/src/00/filestreams.asm", "line": 1135, "sections": {"Inputs": {"D": "Stream ID", "HL": "Value"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamWriteWord", "description": "Writes a 16-bit word to a file stream and advances the stream."}, "streamReadBuffer": {"path": "kernel/src/00/filestreams.asm", "line": 1395, "sections": {"Inputs": {"IX": "Destination address", "D": "Stream ID", "BC": "Length"}, "Notes": "\n If BC is greater than the remaining space in the stream, the stream will be advanced to the end \n before returning an error.", "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamReadBuffer", "description": "Reads a number of bytes from a file stream and advances the stream."}, "openFileWrite": {"path": "kernel/src/00/filestreams.asm", "line": 218, "sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "E": "Garbage (on success)", "D": "File stream ID (on success)"}}, "name": "openFileWrite", "description": "Opens a file stream in write mode. If the file does not exist, it is created."}, "closeStream": {"path": "kernel/src/00/filestreams.asm", "line": 543, "sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "closeStream", "description": "Closes an open stream."}, "streamWriteByte": {"path": "kernel/src/00/filestreams.asm", "line": 1073, "sections": {"Inputs": {"A": "Value", "D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamWriteByte", "description": "Writes a single byte to a file stream and advances the stream."}, "streamReadByte": {"path": "kernel/src/00/filestreams.asm", "line": 1157, "sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Data read (on success); Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamReadByte", "description": "Reads a single byte from a file stream and advances the stream."}, "openFileRead": {"path": "kernel/src/00/filestreams.asm", "line": 49, "sections": {"Inputs": {"DE": "Path to file (string pointer)"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "E": "Garbage (on success)", "D": "File stream ID (on success)"}}, "name": "openFileRead", "description": "Opens a file stream in read-only mode."}, "getStreamPos": {"path": "kernel/src/00/filestreams.asm", "line": 1785, "sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "EBC": "Offset to start of file in bytes"}}, "name": "getStreamPos", "description": "Returns the current position in a file stream."}, "flush": {"path": "kernel/src/00/filestreams.asm", "line": 795, "sections": {"Inputs": {"D": "Stream ID"}, "Notes": "\n This happens periodically as you write to the stream, and happens \n automatically on closeStream. Try not to use it unless you have to.", "Outputs": {"A": "Preserved on success; error code on error", "Z": "Set on success, reset on error"}}, "name": "flush", "description": "Flushes pending writes to disk."}, "streamReadToEnd": {"path": "kernel/src/00/filestreams.asm", "line": 1641, "sections": {"Inputs": {"IX": "Destination address", "D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "streamReadToEnd", "description": "Reads the remainder of a file stream into memory."}, "streamReadWord": {"path": "kernel/src/00/filestreams.asm", "line": 1267, "sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "HL": "Data read (on success)"}}, "name": "streamReadWord", "description": "Reads a 16-bit word from a file stream and advances the stream."}, "seek": {"path": "kernel/src/00/filestreams.asm", "line": 1694, "sections": {"Inputs": {"D": "Stream ID", "EBC": "Offset to start of file in bytes"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure"}}, "name": "seek", "description": "Moves the current position in a file stream."}, "getStreamInfo": {"path": "kernel/src/00/filestreams.asm", "line": 1542, "sections": {"Inputs": {"D": "Stream ID"}, "Outputs": {"A": "Error code (on failure)", "Z": "Set on success, reset on failure", "EBC": "Remaining space in stream (on success)"}}, "name": "getStreamInfo", "description": "Gets the amount of space remaining in a file stream."}}}